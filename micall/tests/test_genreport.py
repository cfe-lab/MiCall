from io import StringIO
from unittest import TestCase

import pytest

from micall.resistance.genreport import ReportTemplate, ReportPage, read_config, read_resistance, read_mutations


class GenReportTest(TestCase):
    def test_unknown_keys(self):
        with self.assertRaisesRegex(
                ValueError,
                r"Unknown configuration: bogus_key, weird_key."):
            ReportTemplate(dict(weird_key="Hello",
                                known_regions=['R1', 'R2'],
                                bogus_key=42))

    def test_missing_keys(self):
        with self.assertRaisesRegex(
                ValueError,
                r"Missing configuration: failure_message, generated_by_text, "
                r"known_drug_classes, known_drugs, report_title, "
                r"resistance_level_colours."):
            ReportTemplate(dict(known_regions=['R1', 'R2'],
                                disclaimer_text="Hello."),
                           raise_missing=True)

    def test_register_regions(self):
        page1 = ReportTemplate(dict(known_regions=['R1', 'R2']))
        page2 = ReportTemplate(dict(known_regions=['R3']))
        expected_regions = {'R1': page1,
                            'R2': page1,
                            'R3': page2}
        regions = {}

        page1.register_regions(regions)
        page2.register_regions(regions)

        self.assertEqual(expected_regions, regions)

    def test_register_drug_classes(self):
        page1 = ReportTemplate(dict(known_drug_classes=[('C1', 'Class 1'),
                                                        ('C2', 'Class 2')],
                                    known_drugs={'C1': [('D1', 'Drug 1')],
                                                 'C2': [('D2', 'Drug 2')]}))
        page2 = ReportTemplate(dict(known_drug_classes=[('C3', 'Class 3')],
                                    known_drugs={'C3': [('D3', 'Drug 3')]}))
        expected_drug_classes = {'C1': page1,
                                 'C2': page1,
                                 'C3': page2}
        drug_classes = {}

        page1.register_drug_classes(drug_classes)
        page2.register_drug_classes(drug_classes)

        self.assertEqual(expected_drug_classes, drug_classes)

    def test_repr(self):
        page = ReportTemplate({'report_title': 'Example Report',
                               'known_regions': ['R1', 'R2']})
        expected_repr = "ReportTemplate({'report_title': 'Example Report'})"

        r = repr(page)

        self.assertEqual(expected_repr, r)

    def test_get_reported_drug_classes(self):
        template = ReportTemplate(dict(known_drug_classes=[('C1', 'Class 1'),
                                                           ('C2', 'Class 2')],
                                       known_drugs={'C1': [('D1', 'Drug 1')],
                                                    'C2': [('D2', 'Drug 2')]}))
        genotype = 'g1'
        template.genotype_pages[genotype] = ReportPage(
            resistance_calls={'D1': 'Some resistance data'},
            mutations={})
        expected_genotypes = [genotype]
        expected_drug_classes = {'C1'}
        expected_drugs = {'D1'}

        reported_genotypes = template.get_reported_genotypes()
        reported_drug_classes = template.get_reported_drug_classes(genotype)
        reported_drugs = template.get_reported_drugs(genotype)

        self.assertEqual(expected_genotypes, reported_genotypes)
        self.assertEqual(expected_drug_classes, reported_drug_classes)
        self.assertEqual(expected_drugs, reported_drugs)


def test_read_config():
    expected_prefix = 'Generated by MiCall vX.Y on Illumina BaseSpace'
    report_templates = read_config('vX.Y')

    template = report_templates[0]
    assert template.virus_config['generated_by_text'].startswith(expected_prefix)


def test_bad_config_type():
    match = (r"Configuration in .*/genreport\.yaml must be a\s+single dict "
             r"class, but found a <class 'str'>")
    with pytest.raises(ValueError, match=match):
        ReportTemplate('some bogus configuration')


def test_bad_colour_config():
    config = dict(resistance_level_colours={
        1: ['Susceptible', 0xDEFBDE]
    })

    match = (r"Error in configuration file: resistance_level_colours must have "
             r"3 entries: \['Susceptible', 14613470]")
    with pytest.raises(ValueError, match=(r"%s" % match)):
        ReportTemplate(config)


def test_bad_colour_type():
    config = dict(resistance_level_colours={
        1: ['Susceptible', 0xDEFBDE, 'blue']
    })

    match = (r"Error in configuration file: resistance_level_colours "
             r"string, int, int expected \['Susceptible', 14613470, 'blue']")
    with pytest.raises(ValueError, match=(r"%s" % match)):
        ReportTemplate(config)


def test_inconsistent_drug_classes():
    config = dict(known_drugs=dict(class_a=[('code1', 'name 1a')],
                                   class_b=[('code3', 'name 3b')]),
                  known_drug_classes=[('class_a', 'name a'),
                                      ('class_c', 'name c')])

    match = (r"Error in configuration file: known_drugs inconsistent with "
             r"drug_classes")
    with pytest.raises(ValueError, match=(r"%s" % match)):
        ReportTemplate(config)


def test_duplicate_drug_codes():
    config = dict(known_drugs=dict(class_a=[('code1', 'name 1a'),
                                            ('code2a', 'name 2a'),
                                            ('code3', 'name 3a')],
                                   class_b=[('code1', 'name 1b'),
                                            ('code2b', 'name 2b'),
                                            ('code3', 'name 3b')]),
                  known_drug_classes=[('class_a', 'name a'),
                                      ('class_b', 'name b')])

    match = (r"Error in configuration file: known_drugs duplicate drug "
             r"identifiers: code1, code3.")
    with pytest.raises(ValueError, match=(r"%s" % match)):
        ReportTemplate(config)


def test_duplicate_drug_names():
    config = dict(known_drugs=dict(class_a=[('code1a', 'name 1a'),
                                            ('code2a', 'name 2'),
                                            ('code3a', 'name 3')],
                                   class_b=[('code1b', 'name 1b'),
                                            ('code2b', 'name 2'),
                                            ('code3b', 'name 3')]),
                  known_drug_classes=[('class_a', 'name a'),
                                      ('class_b', 'name b')])

    match = (r"Error in configuration file: known_drugs duplicate drug names: "
             r"name 2, name 3.")
    with pytest.raises(ValueError, match=(r"%s" % match)):
        ReportTemplate(config)


def test_read_resistance():
    resistance_csv = StringIO("""\
region,drug_class,drug,drug_name,level,level_name,score,genotype,seed,coord_region,version
RT,NRTI,3TC,lamivudine,1,Susceptible,0.0,,HIV1B-seed,RT,9.0
""")
    config = read_config('vX.Y')
    report_template = config[0]
    regions = {}
    report_template.register_regions(regions)
    read_resistance(regions, resistance_csv)

    page = report_template.genotype_pages['']

    assert page.resistance_calls['3TC'] == (1, 'Susceptible')


def test_read_mutations():
    mutations_csv = StringIO("""\
drug_class,mutation,prevalence,genotype,region,seed,coord_region,version
NRTI,M41L,0.06,,RT,HIV1B-seed,RT,9.0
""")
    config = read_config('vX.Y')
    report_template = config[0]
    drug_classes = {}
    report_template.register_drug_classes(drug_classes)
    read_mutations(drug_classes, mutations_csv)

    page = report_template.genotype_pages['']

    assert page.mutations['NRTI'] == 'M41L(6%)'


# Configuration consistency validation tests
# These tests catch configuration mismatches between resistance.py and genreport.yaml
# that would otherwise only be discovered at runtime or during integration testing.

def test_reported_regions_in_genreport_config():
    """All REPORTED_REGIONS must exist in genreport.yaml known_regions.
    
    Prevents: KeyError when genreport.py tries to process resistance CSV
    containing regions from resistance.py that aren't configured.
    """
    from micall.resistance.resistance import REPORTED_REGIONS
    
    config = read_config('vX.Y')
    report_template = config[0]
    known_regions = report_template.virus_config['known_regions']
    
    # Filter to HIV regions (exclude HCV)
    hiv_reported = {r for r in REPORTED_REGIONS if r not in ('NS3', 'NS5a', 'NS5b')}
    
    missing = hiv_reported - known_regions
    assert not missing, (
        f"Configuration mismatch: Regions in REPORTED_REGIONS but not in "
        f"genreport.yaml known_regions: {missing}\n"
        f"Fix: Add {missing} to known_regions list in micall/resistance/genreport.yaml"
    )


def test_algorithm_drugs_in_genreport_config():
    """All drugs from HIVdb algorithm must be in genreport.yaml known_drugs.
    
    Prevents: ValueError 'Unknown drug codes' when PDF generation encounters
    drugs returned by the algorithm that aren't configured.
    """
    from micall.resistance.resistance import load_asi
    
    algorithms = load_asi()
    config = read_config('vX.Y')
    report_template = config[0]
    known_drugs = report_template.virus_config['known_drugs']
    
    configured_drugs = {
        code for drug_class in known_drugs.values()
        for code, name in drug_class
    }
    
    hiv_algorithm = algorithms[None]
    algorithm_drugs = set()
    for drug_list in hiv_algorithm.drug_class.values():
        algorithm_drugs.update(drug_list)
    
    missing = algorithm_drugs - configured_drugs
    assert not missing, (
        f"Configuration mismatch: Drugs in HIV algorithm but not in "
        f"genreport.yaml: {missing}\n"
        f"Fix: Add these drugs to appropriate drug_class in "
        f"micall/resistance/genreport.yaml known_drugs section"
    )


def test_algorithm_drug_classes_in_genreport():
    """All drug classes from algorithm must be in genreport.yaml.
    
    Prevents: KeyError when trying to organize drugs by class for reporting.
    """
    from micall.resistance.resistance import load_asi
    
    algorithms = load_asi()
    config = read_config('vX.Y')
    report_template = config[0]
    known_drugs = report_template.virus_config['known_drugs']
    known_classes = set(known_drugs.keys())
    
    hiv_algorithm = algorithms[None]
    algorithm_classes = set(hiv_algorithm.drug_class.keys())
    
    missing = algorithm_classes - known_classes
    assert not missing, (
        f"Configuration mismatch: Drug classes in algorithm but not in "
        f"genreport.yaml: {missing}\n"
        f"Fix: Add these drug classes to known_drugs and known_drug_classes "
        f"in micall/resistance/genreport.yaml"
    )


def test_genreport_drug_class_definitions_complete():
    """All drug classes in known_drugs must also be in known_drug_classes list.
    
    Prevents: Drugs being defined but never displayed in reports.
    """
    config = read_config('vX.Y')
    report_template = config[0]
    virus_config = report_template.virus_config
    
    known_drugs = virus_config['known_drugs']
    # After processing, known_drug_classes is a frozenset of drug class codes
    known_drug_classes_set = virus_config.get('known_drug_classes', frozenset())
    
    defined_classes = set(known_drugs.keys())
    
    missing = defined_classes - known_drug_classes_set
    assert not missing, (
        f"Configuration error: Drug classes defined in known_drugs but not "
        f"in known_drug_classes list: {missing}\n"
        f"Fix: Add to known_drug_classes list in genreport.yaml"
    )


def test_algorithm_regions_processable():
    """All regions from algorithm gene_def can be processed without errors.
    
    Prevents: Runtime errors when filter_aminos tries to create empty
    structures for algorithm regions.
    """
    from micall.resistance.resistance import (
        load_asi, get_algorithm_regions, create_empty_aminos
    )
    
    algorithms = load_asi()
    hiv_algorithm = algorithms[None]
    regions = get_algorithm_regions(hiv_algorithm)
    
    errors = []
    for region in regions:
        try:
            empty = create_empty_aminos(region, None, 'HIV1B-seed', algorithms)
            assert empty.region == region
            assert len(empty.aminos) > 0
        except Exception as e:
            errors.append(f"{region}: {str(e)}")
    
    assert not errors, (
        f"Cannot process algorithm regions: {errors}\n"
        f"Fix: Ensure all algorithm regions have proper reference sequences "
        f"and can be instantiated"
    )


def test_no_orphaned_drugs_in_config():
    """Warn if genreport.yaml has drugs not in any algorithm.
    
    Prevents: Configuration drift where drugs are configured but never used.
    This is a warning test - it identifies potential cleanup opportunities.
    """
    from micall.resistance.resistance import load_asi
    
    algorithms = load_asi()
    config = read_config('vX.Y')
    report_template = config[0]
    known_drugs = report_template.virus_config['known_drugs']
    
    configured_drugs = {
        code for drug_class in known_drugs.values()
        for code, name in drug_class
    }
    
    # Collect drugs from all algorithms (HIV and HCV)
    algorithm_drugs = set()
    for algorithm in algorithms.values():
        for drug_list in algorithm.drug_class.values():
            algorithm_drugs.update(drug_list)
    
    orphaned = configured_drugs - algorithm_drugs
    
    # This is informational, not a hard failure
    if orphaned:
        import warnings
        warnings.warn(
            f"Drugs in genreport.yaml but not in any algorithm: {orphaned}. "
            f"These may be obsolete or for future use.",
            UserWarning
        )


def test_region_name_mapping_consistency():
    """Verify IN/INT region name mapping is handled correctly.
    
    Prevents: Bugs due to inconsistent region naming (IN in algorithm vs INT in code).
    """
    from micall.resistance.resistance import (
        load_asi, get_algorithm_regions, get_reported_region
    )
    
    algorithms = load_asi()
    hiv_algorithm = algorithms[None]
    
    # Algorithm uses 'IN', code uses 'INT'
    if 'IN' in hiv_algorithm.gene_def:
        regions = get_algorithm_regions(hiv_algorithm)
        assert 'INT' in regions, "get_algorithm_regions should map IN to INT"
        
        # get_reported_region should map back
        assert get_reported_region('INT') == 'IN', "Should map INT back to IN for reporting"


def test_drug_class_to_drug_mapping():
    """Verify drugs are assigned to correct classes in both algorithm and config.
    
    Prevents: Drugs appearing under wrong drug class in reports.
    """
    from micall.resistance.resistance import load_asi
    
    algorithms = load_asi()
    config = read_config('vX.Y')
    report_template = config[0]
    known_drugs = report_template.virus_config['known_drugs']
    
    hiv_algorithm = algorithms[None]
    
    # For each drug class in config, verify drugs match algorithm
    errors = []
    for drug_class, drugs in known_drugs.items():
        config_drugs = {code for code, name in drugs}
        
        # Get drugs from algorithm for this class
        algo_drugs = set(hiv_algorithm.drug_class.get(drug_class, []))
        
        # Drugs in config but not in algorithm's class (might be in different class)
        misplaced = config_drugs - algo_drugs
        if misplaced:
            # Check if they exist in algorithm at all
            all_algo_drugs = set()
            for dc, drug_list in hiv_algorithm.drug_class.items():
                all_algo_drugs.update(drug_list)
            
            for drug in misplaced:
                if drug in all_algo_drugs:
                    # Find which class it's actually in
                    actual_class = None
                    for dc, drug_list in hiv_algorithm.drug_class.items():
                        if drug in drug_list:
                            actual_class = dc
                            break
                    errors.append(
                        f"Drug {drug} in {drug_class} but algorithm has it in {actual_class}"
                    )
    
    assert not errors, (
        f"Drug class assignment mismatch:\n" + "\n".join(errors) +
        f"\nFix: Move drugs to correct drug_class in genreport.yaml"
    )
