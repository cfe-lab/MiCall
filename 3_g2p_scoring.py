"""
Generate V3-specific nucleotide sequence from remapped env .fasta file
Along with G2PFPR score in the header

Input: <sample>.<region>.remap.sam.<qCutoff>.fasta.<minCount>.seq
Output: <sample>.<region>.remap.sam.<qCutoff>.fasta.<minCount>.seq.V3
"""

# After remapping, dashes introduced into env sequence due to alignment
# Strip out dashes at this step

import os
import sys
from glob import glob
from Bio import SeqIO
from seqUtils import *
from hyphyAlign import *
from minG2P import conan_g2p

hyphy = HyPhy._THyPhy (os.getcwd(), 1)
change_settings(hyphy) 										# Default settings are for protein alignment

refseq = translate_nuc(refSeqs['V3, clinical'], 0)			# refSeq is V3 (HXB2: 7110-7217) in nucleotide space


# which file to handle?
f = sys.argv[1]
if not f.endswith('.fasta'):
	print 'Expecting filename ending with .fasta extension'
	sys.exit()

infile = open(f, 'rU')
try:
	fasta = convert_fasta(infile.readlines())
except:
	print 'failed to convert', f
	sys.exit()

infile.close()



# Determine correct offset off the first sequence
# to correct for frameshift induced by sample/region-specific remapping
envSeq1 = fasta[0][1].strip("-")
best_offset = 0
best_score = -999
for offset in range(3):					# range(3) = [0, 1, 2]
	aaEnvSeq = translate_nuc(envSeq1, offset)
	aquery, aref, ascore = pair_align(hyphy, refseq, aaEnvSeq)
	if ascore > best_score:
		best_offset = offset
		best_score = ascore



# For each env sequence, extract V3 nucleotide sequence
badfile = open(f.replace('.fasta', '.badV3'), 'w')
v3nucs = {}

for header, envSeq in fasta:
	envSeq = envSeq.strip("-")						# Strip dashes at flanking regions generated by alignment
	aaEnvSeq = translate_nuc(envSeq, best_offset)	# Translate env on the correct offset (ORF)
	
	aquery, aref, ascore = pair_align(hyphy, refseq, aaEnvSeq)
	left, right = get_boundaries(aref)									# Get left/right boundaries of V3 protein
	v3prot = aquery[left:right]											# Extract V3 protein
	v3nuc = apply2nuc(envSeq[(3*left):], v3prot, aref[left:right], 		# use alignment to extract V3 nuc. seq
					keepIns=True, keepDel=False)
	
	# Conditions for dropping data
	# 1) Censored bases were detected ('N')
	# 2) V3 didn't start with C, end with C
	# 3) V3 didn't contain an internal stop codon ('*')
	# 4) Alignment score less than 50
	
	if 'N' in v3nuc or not v3prot.startswith('C') or not v3prot.endswith('C') or '*' in v3prot or ascore < 50:
		# screen for bad V3 sequences, provide reason(s)
		badfile.write('>%s_variant_%d_count_%d_reason_%s\n%s\n' % (prefix, i, count,
			'|'.join(['stopcodon' if '*' in v3prot else '',
					'lowscore' if ascore < 50 else '',
					'cystines' if not v3prot.startswith('C') or not v3prot.endswith('C') else '',
					'ambig' if 'N' in v3nuc else '']),
			seq))
	else:
		# this looks like a legitimate V3-encoding sequence
		if v3nucs.has_key(v3nuc):
			v3nucs[v3nuc] += count
		else:
			v3nucs.update({v3nuc: count})

badfile.close()




# calculate g2p scores
v3prots = {}
for v3nuc, count in v3nucs.iteritems():
	g2p, fpr, aligned = conan_g2p(v3nuc)
	if g2p is None:
		continue
	
	if v3prots.has_key(aligned):
		v3prots[aligned]['count'] += count
	else:
		v3prots.update({aligned: {'count': count, 'fpr': fpr}})



# collect identical V3 amino acid sequences and output
intermed = [(v['count'], k) for k, v in v3prots.iteritems()]
intermed.sort(reverse=True)

v3protfile = open(f.replace('.fasta', '.v3prot'), 'w')

for i, (count, v3prot) in enumerate(intermed):
	fpr = v3prots[v3prot]['fpr']
	v3protfile.write('>%s_variant_%d_count_%d_fpr_%s\n%s\n' % (prefix, i, count, fpr, v3prot))


v3protfile.close()




